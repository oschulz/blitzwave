<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>

<title>bwave::WaveletDecomp&lt; tp_rank &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>bwave</b>      </li>
      <li class="navelem"><a class="el" href="classbwave_1_1WaveletDecomp.html">WaveletDecomp</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">bwave::WaveletDecomp&lt; tp_rank &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="bwave::WaveletDecomp" -->
<p>Represents a specific wavelet decomposition.  
 <a href="classbwave_1_1WaveletDecomp.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="WaveletDecomp_8h_source.html">WaveletDecomp.h</a>&gt;</code></p>

<p><a href="classbwave_1_1WaveletDecomp-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2517305dd2b926d7cd0fe4b104482db3"></a><!-- doxytag: member="bwave::WaveletDecomp::wavelet" ref="a2517305dd2b926d7cd0fe4b104482db3" args="() const " -->
const <a class="el" href="classbwave_1_1Wavelet.html">Wavelet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#a2517305dd2b926d7cd0fe4b104482db3">wavelet</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the wavelet used in this decomposition. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19f0705bd099bed3b797089529dd43e2"></a><!-- doxytag: member="bwave::WaveletDecomp::decompType" ref="a19f0705bd099bed3b797089529dd43e2" args="() const " -->
DecompType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#a19f0705bd099bed3b797089529dd43e2">decompType</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of this decomposition (i.e. standard or non-standard). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc2ceed04857afb3e461873c06b5c43b"></a><!-- doxytag: member="bwave::WaveletDecomp::maxLevel" ref="afc2ceed04857afb3e461873c06b5c43b" args="() const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#afc2ceed04857afb3e461873c06b5c43b">maxLevel</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum decomposition level. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CoeffStorage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#a0d51787edf5dc539915cdc08736deff6">storageMode</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mode in which the wavelet/scaling coefficients are stored.  <a href="#a0d51787edf5dc539915cdc08736deff6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CoeffStorage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#a141d7f32187ccf3505b11a93ca14754e">storageMode</a> (CoeffStorage newCS)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the mode in which the wavelet/scaling coefficients are stored.  <a href="#a141d7f32187ccf3505b11a93ca14754e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ExtensionMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#ae26d5ab9b356f70380374b3d73f416e8">extensionMode</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current method used for boundary handling / array extension.  <a href="#ae26d5ab9b356f70380374b3d73f416e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ExtensionMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#a219c8086b941f0586656e0d3b4a13b86">extensionMode</a> (ExtensionMode newEM)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the method to be used for boundary handling / array extension.  <a href="#a219c8086b941f0586656e0d3b4a13b86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57fac16e2fff0f660305cb8ba49fb894"></a><!-- doxytag: member="bwave::WaveletDecomp::selectedDims" ref="a57fac16e2fff0f660305cb8ba49fb894" args="()" -->
const blitz::TinyVector&lt; bool, <br class="typebreak"/>
tp_rank &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#a57fac16e2fff0f660305cb8ba49fb894">selectedDims</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the selected dimensions. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a498f6c2d9239b44033a9e71da5993c92"></a><!-- doxytag: member="bwave::WaveletDecomp::dimSelected" ref="a498f6c2d9239b44033a9e71da5993c92" args="(int dim) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#a498f6c2d9239b44033a9e71da5993c92">dimSelected</a> (int dim) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if decomposition will be applied in array dimension <code>dim</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">blitz::TinyVector&lt; bool, tp_rank &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#a3b743a86f4d63c9301c149f44b525bae">dimSelection</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimensions selected for decomposition.  <a href="#a3b743a86f4d63c9301c149f44b525bae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">blitz::TinyVector&lt; bool, tp_rank &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#a2fcbaf31109a9a7b6a0e4fad1d23d4c6">dimSelection</a> (blitz::TinyVector&lt; bool, tp_rank &gt; selection)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the dimensions in which to apply the wavelet decomposition.  <a href="#a2fcbaf31109a9a7b6a0e4fad1d23d4c6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class tp_Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">blitz::TinyVector&lt; int, tp_rank &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#abcf0d45cb9254f2beeac698c22b2abb9">apply</a> (blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply this wavelet decomposition to a data array.  <a href="#abcf0d45cb9254f2beeac698c22b2abb9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class tp_Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">blitz::TinyVector&lt; int, tp_rank &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#accdacebb53ce2791c965cdde9eb428d2">applyInv</a> (blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the inverse wavelet transformation.  <a href="#accdacebb53ce2791c965cdde9eb428d2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class tp_Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">blitz::Array<br class="typebreak"/>
&lt; blitz::TinyVector&lt; int, <br class="typebreak"/>
tp_rank &gt;, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#af170075b1e6a180a31bb3e4316f8207d">indices</a> (blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the indices of the coefficients that this decomposition will/has produce(d) for the given data.  <a href="#af170075b1e6a180a31bb3e4316f8207d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class tp_Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">blitz::Array&lt; tp_Type, tp_rank &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#a59b6b6a3648a973452cb5b7b5b504ed4">coeffs</a> (blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data, blitz::TinyVector&lt; int, tp_rank &gt; <a class="el" href="classbwave_1_1WaveletDecomp.html#af170075b1e6a180a31bb3e4316f8207d">indices</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all wavelet/scaling coefficients of the same type (i.e. corresponding to basis functions differing only by translation)  <a href="#a59b6b6a3648a973452cb5b7b5b504ed4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#a2650a3646c51ed0b3ae2f4601de6481a">normFactor</a> (blitz::TinyVector&lt; int, tp_rank &gt; <a class="el" href="classbwave_1_1WaveletDecomp.html#af170075b1e6a180a31bb3e4316f8207d">indices</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the normalization factor for the specified coefficient type.  <a href="#a2650a3646c51ed0b3ae2f4601de6481a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#a23e94341febe032439cd62fbd1fdb897">WaveletDecomp</a> (<a class="el" href="classbwave_1_1WaveletDecomp.html">WaveletDecomp</a>&lt; tp_rank &gt; other, CoeffStorage cs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy other decomposition while changing coefficient storage mode.  <a href="#a23e94341febe032439cd62fbd1fdb897"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbwave_1_1WaveletDecomp.html#aadd0a73ee7ba2f8d5ef1f77cb48442cb">WaveletDecomp</a> (<a class="el" href="classbwave_1_1Wavelet.html">Wavelet</a> wl, DecompType decomp=NONSTD_DECOMP, int maxlevel=0, CoeffStorage cs=NESTED_COEFFS, ExtensionMode em=CONSTANT_EXT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new wavelet decomposition.  <a href="#aadd0a73ee7ba2f8d5ef1f77cb48442cb"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1e092a810149ca0e0a18ff681915d505"></a><!-- doxytag: member="bwave::WaveletDecomp::trafoStep" ref="a1e092a810149ca0e0a18ff681915d505" args="(blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data, int targetDim, bool inverse) const " -->
template&lt;class tp_Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trafoStep</b> (blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data, int targetDim, bool inverse) const </td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ac5ba82ffcabed940537af03b9e157136"></a><!-- doxytag: member="bwave::WaveletDecomp::waveletDecompose" ref="ac5ba82ffcabed940537af03b9e157136" args="(blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data, int maxlevel=0) const " -->
template&lt;class tp_Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">blitz::TinyVector&lt; int, tp_rank &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>waveletDecompose</b> (blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data, int maxlevel=0) const </td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8f34f74f46df524335fd1f466e8e599f"></a><!-- doxytag: member="bwave::WaveletDecomp::waveletRecompose" ref="a8f34f74f46df524335fd1f466e8e599f" args="(blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data, int maxlevel=0) const " -->
template&lt;class tp_Type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">blitz::TinyVector&lt; int, tp_rank &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>waveletRecompose</b> (blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data, int maxlevel=0) const </td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd0e8af7873cb624c229c3c837e19467"></a><!-- doxytag: member="bwave::WaveletDecomp::m_wavelet" ref="abd0e8af7873cb624c229c3c837e19467" args="" -->
<a class="el" href="classbwave_1_1Wavelet.html">Wavelet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_wavelet</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ed3c7720e6361de3c35603a4c29017c"></a><!-- doxytag: member="bwave::WaveletDecomp::m_decomp" ref="a9ed3c7720e6361de3c35603a4c29017c" args="" -->
DecompType&#160;</td><td class="memItemRight" valign="bottom"><b>m_decomp</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a215c93c60a7af9e377ea4f5afe82e254"></a><!-- doxytag: member="bwave::WaveletDecomp::m_storageMode" ref="a215c93c60a7af9e377ea4f5afe82e254" args="" -->
CoeffStorage&#160;</td><td class="memItemRight" valign="bottom"><b>m_storageMode</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60659292de9373c3dd7ef000af77b8ac"></a><!-- doxytag: member="bwave::WaveletDecomp::m_extMode" ref="a60659292de9373c3dd7ef000af77b8ac" args="" -->
ExtensionMode&#160;</td><td class="memItemRight" valign="bottom"><b>m_extMode</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a082f8150f0e4ca9cfa8aac0f14ba13be"></a><!-- doxytag: member="bwave::WaveletDecomp::m_maxLevel" ref="a082f8150f0e4ca9cfa8aac0f14ba13be" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_maxLevel</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae77e6cdc5aa75535bccf3ca775bac7b9"></a><!-- doxytag: member="bwave::WaveletDecomp::m_dimSelect" ref="ae77e6cdc5aa75535bccf3ca775bac7b9" args="" -->
blitz::TinyVector&lt; bool, tp_rank &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_dimSelect</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;int tp_rank&gt;<br/>
class bwave::WaveletDecomp&lt; tp_rank &gt;</h3>

<p>Represents a specific wavelet decomposition. </p>
<p>Instances of <a class="el" href="classbwave_1_1WaveletDecomp.html" title="Represents a specific wavelet decomposition.">WaveletDecomp</a> specify the details of a wavelet decomposition, which can then be applied to data of any type but fixed dimensionality. The data dimensionality is set with the template parameter <code>tp_rank</code>. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a23e94341febe032439cd62fbd1fdb897"></a><!-- doxytag: member="bwave::WaveletDecomp::WaveletDecomp" ref="a23e94341febe032439cd62fbd1fdb897" args="(WaveletDecomp&lt; tp_rank &gt; other, CoeffStorage cs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::<a class="el" href="classbwave_1_1WaveletDecomp.html">WaveletDecomp</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbwave_1_1WaveletDecomp.html">WaveletDecomp</a>&lt; tp_rank &gt;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoeffStorage&#160;</td>
          <td class="paramname"><em>cs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy other decomposition while changing coefficient storage mode. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Decomposition to copy </td></tr>
    <tr><td class="paramname">cs</td><td>Coefficient storage mode</td></tr>
  </table>
  </dd>
</dl>
<p>Useful to work with data in different coefficient storage modes. </p>

</div>
</div>
<a class="anchor" id="aadd0a73ee7ba2f8d5ef1f77cb48442cb"></a><!-- doxytag: member="bwave::WaveletDecomp::WaveletDecomp" ref="aadd0a73ee7ba2f8d5ef1f77cb48442cb" args="(Wavelet wl, DecompType decomp=NONSTD_DECOMP, int maxlevel=0, CoeffStorage cs=NESTED_COEFFS, ExtensionMode em=CONSTANT_EXT)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::<a class="el" href="classbwave_1_1WaveletDecomp.html">WaveletDecomp</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbwave_1_1Wavelet.html">Wavelet</a>&#160;</td>
          <td class="paramname"><em>wl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DecompType&#160;</td>
          <td class="paramname"><em>decomp</em> = <code>NONSTD_DECOMP</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxlevel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoeffStorage&#160;</td>
          <td class="paramname"><em>cs</em> = <code>NESTED_COEFFS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExtensionMode&#160;</td>
          <td class="paramname"><em>em</em> = <code>CONSTANT_EXT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a new wavelet decomposition. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">wavelet</td><td><a class="el" href="classbwave_1_1Wavelet.html" title="General Wavelet class.">Wavelet</a> to use in the decomposition. </td></tr>
    <tr><td class="paramname">decomp</td><td>Decomposition type. </td></tr>
    <tr><td class="paramname">maxlevel</td><td>Maximum decomposition depth </td></tr>
    <tr><td class="paramname">cs</td><td>Coefficient storage mode </td></tr>
    <tr><td class="paramname">em</td><td>Internal array extension / boundary handling method</td></tr>
  </table>
  </dd>
</dl>
<p>The decomposition can directly be applied to data after construction, no further preparation is necessary.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>apply(blitz::Array&lt;tp_Type,tp_rank&gt; &amp;data) </dd>
<dd>
applyInv(blitz::Array&lt;tp_Type,tp_rank&gt; &amp;data) </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abcf0d45cb9254f2beeac698c22b2abb9"></a><!-- doxytag: member="bwave::WaveletDecomp::apply" ref="abcf0d45cb9254f2beeac698c22b2abb9" args="(blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
<div class="memtemplate">
template&lt;class tp_Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">blitz::TinyVector&lt;int, tp_rank&gt; <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::<a class="el" href="classbwave_1_1WaveletDecomp.html#abcf0d45cb9254f2beeac698c22b2abb9">apply</a> </td>
          <td>(</td>
          <td class="paramtype">blitz::Array&lt; tp_Type, tp_rank &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply this wavelet decomposition to a data array. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be decomposed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A vector of the decomposition depths in the different data dimensions.</dd></dl>
<p>Does a wavelet decomposition given on the given data. The data is wavelet-decomposed in-place, <a class="el" href="classbwave_1_1WaveletDecomp.html#a0d51787edf5dc539915cdc08736deff6" title="Get the mode in which the wavelet/scaling coefficients are stored.">storageMode()</a> must be <code>NESTED_COEFFS</code>. Afterwards, data array contains the wavelet/scaling coefficients, use the <code>coeffs</code>(..) method for coefficient access. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>coeffs(blitz::Array&lt;tp_Type,tp_rank&gt; &amp;data, blitz::TinyVector&lt;int, tp_rank&gt; indices) </dd></dl>

<p>References <a class="el" href="classbwave_1_1WaveletDecomp.html#a0d51787edf5dc539915cdc08736deff6">bwave::WaveletDecomp&lt; tp_rank &gt;::storageMode()</a>.</p>

<p>Referenced by <a class="el" href="classbwave_1_1Wavelet.html#a2a75aacf6645d191078a839d1be5a70f">bwave::Wavelet::forwardFkt()</a>.</p>

</div>
</div>
<a class="anchor" id="accdacebb53ce2791c965cdde9eb428d2"></a><!-- doxytag: member="bwave::WaveletDecomp::applyInv" ref="accdacebb53ce2791c965cdde9eb428d2" args="(blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
<div class="memtemplate">
template&lt;class tp_Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">blitz::TinyVector&lt;int, tp_rank&gt; <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::<a class="el" href="classbwave_1_1WaveletDecomp.html#accdacebb53ce2791c965cdde9eb428d2">applyInv</a> </td>
          <td>(</td>
          <td class="paramtype">blitz::Array&lt; tp_Type, tp_rank &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply the inverse wavelet transformation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The wavelet/scaling coefficients. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A vector of the recomposition depths in the different data dimensions.</dd></dl>
<p>Does a wavelet recomposition using the given coefficients. The recomposition is done in-place, <a class="el" href="classbwave_1_1WaveletDecomp.html#a0d51787edf5dc539915cdc08736deff6" title="Get the mode in which the wavelet/scaling coefficients are stored.">storageMode()</a> must be <code>NESTED_COEFFS</code>. Afterwards, the data array contains the recomposed data. </p>

<p>References <a class="el" href="classbwave_1_1WaveletDecomp.html#a0d51787edf5dc539915cdc08736deff6">bwave::WaveletDecomp&lt; tp_rank &gt;::storageMode()</a>.</p>

<p>Referenced by <a class="el" href="classbwave_1_1Wavelet.html#ab602c1aa2aab908f3d75f9160bf9dddc">bwave::Wavelet::inverseFkt()</a>.</p>

</div>
</div>
<a class="anchor" id="a59b6b6a3648a973452cb5b7b5b504ed4"></a><!-- doxytag: member="bwave::WaveletDecomp::coeffs" ref="a59b6b6a3648a973452cb5b7b5b504ed4" args="(blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data, blitz::TinyVector&lt; int, tp_rank &gt; indices) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
<div class="memtemplate">
template&lt;class tp_Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">blitz::Array&lt; tp_Type, tp_rank &gt; <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::<a class="el" href="classbwave_1_1WaveletDecomp.html#a59b6b6a3648a973452cb5b7b5b504ed4">coeffs</a> </td>
          <td>(</td>
          <td class="paramtype">blitz::Array&lt; tp_Type, tp_rank &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">blitz::TinyVector&lt; int, tp_rank &gt;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get all wavelet/scaling coefficients of the same type (i.e. corresponding to basis functions differing only by translation) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The decomposed data to extract the coefficients from. </td></tr>
    <tr><td class="paramname">indices</td><td>An index vector specifying the coefficient type to extract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An array of the coefficients. This not a copy of the relevant parts of <code>data</code>, but a reference to them.</dd></dl>
<p><a class="el" href="classbwave_1_1Wavelet.html" title="General Wavelet class.">Wavelet</a> decomposition of multi-dimensional, non-square data array produces coefficients coefficients corresponding to lots of scaled and translated basis functions, which are themselves mixed products of the basic scaling and wavelet function. Coefficients which differ only by the translation of their basic function are said here to be of the same <em>type</em>. These coefficient types are designated here by an index vector. It's components specify the factory of the basis function in the respective dimensions. A positive value specifies a scaling function, a negative one a wavelet function. The component's absolute value specifies the scale as an exponent of 2.</p>
<p>Example: Let Phi_i be the scaling, Psi_i be the wavelet function of scale i. Let the data have three dimensions x,y,z. Then the coefficients corresponding to the basis function Psi_4(x)*Phi_3(y)*Psi_3(z) would have the index vector (-4, 3, -3).</p>
<p>The bases function Phi_0 can be said to correspond to original, non-decomposed data. Therefore, if data is not decomposed in some dimensions, the only valid index vector component in these dimensions is 0.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This method does <em>not</em> check if the requested coefficient type exists for this decomposition and the given coefficient data. The method <code>indices</code>(...) can be used to get a list of valid index vectors. </dd></dl>

<p>Referenced by <a class="el" href="classbwave_1_1Wavelet.html#a2a75aacf6645d191078a839d1be5a70f">bwave::Wavelet::forwardFkt()</a>, and <a class="el" href="classbwave_1_1Wavelet.html#ab602c1aa2aab908f3d75f9160bf9dddc">bwave::Wavelet::inverseFkt()</a>.</p>

</div>
</div>
<a class="anchor" id="a3b743a86f4d63c9301c149f44b525bae"></a><!-- doxytag: member="bwave::WaveletDecomp::dimSelection" ref="a3b743a86f4d63c9301c149f44b525bae" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">blitz::TinyVector&lt;bool, tp_rank&gt; <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::<a class="el" href="classbwave_1_1WaveletDecomp.html#a3b743a86f4d63c9301c149f44b525bae">dimSelection</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the dimensions selected for decomposition. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classbwave_1_1WaveletDecomp.html#a2fcbaf31109a9a7b6a0e4fad1d23d4c6" title="Select the dimensions in which to apply the wavelet decomposition.">dimSelection(blitz::TinyVector&lt;bool, tp_rank&gt; selection)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2fcbaf31109a9a7b6a0e4fad1d23d4c6"></a><!-- doxytag: member="bwave::WaveletDecomp::dimSelection" ref="a2fcbaf31109a9a7b6a0e4fad1d23d4c6" args="(blitz::TinyVector&lt; bool, tp_rank &gt; selection)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">blitz::TinyVector&lt;bool, tp_rank&gt; <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::<a class="el" href="classbwave_1_1WaveletDecomp.html#a3b743a86f4d63c9301c149f44b525bae">dimSelection</a> </td>
          <td>(</td>
          <td class="paramtype">blitz::TinyVector&lt; bool, tp_rank &gt;&#160;</td>
          <td class="paramname"><em>selection</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Select the dimensions in which to apply the wavelet decomposition. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">selection</td><td>A boolean vector, set true for the dimensions in which to apply decomposition.</td></tr>
  </table>
  </dd>
</dl>
<p>The wavelet decomposition can be specified to work in all or only some dimensions (data directions). All possible combinations are valid. </p>

</div>
</div>
<a class="anchor" id="ae26d5ab9b356f70380374b3d73f416e8"></a><!-- doxytag: member="bwave::WaveletDecomp::extensionMode" ref="ae26d5ab9b356f70380374b3d73f416e8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ExtensionMode <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::<a class="el" href="classbwave_1_1WaveletDecomp.html#ae26d5ab9b356f70380374b3d73f416e8">extensionMode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current method used for boundary handling / array extension. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>ExtensionMode </dd></dl>

</div>
</div>
<a class="anchor" id="a219c8086b941f0586656e0d3b4a13b86"></a><!-- doxytag: member="bwave::WaveletDecomp::extensionMode" ref="a219c8086b941f0586656e0d3b4a13b86" args="(ExtensionMode newEM)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ExtensionMode <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::<a class="el" href="classbwave_1_1WaveletDecomp.html#ae26d5ab9b356f70380374b3d73f416e8">extensionMode</a> </td>
          <td>(</td>
          <td class="paramtype">ExtensionMode&#160;</td>
          <td class="paramname"><em>newEM</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the method to be used for boundary handling / array extension. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">newEM</td><td>The new array extension method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>ExtensionMode </dd></dl>

</div>
</div>
<a class="anchor" id="af170075b1e6a180a31bb3e4316f8207d"></a><!-- doxytag: member="bwave::WaveletDecomp::indices" ref="af170075b1e6a180a31bb3e4316f8207d" args="(blitz::Array&lt; tp_Type, tp_rank &gt; &amp;data) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
<div class="memtemplate">
template&lt;class tp_Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">blitz::Array&lt; blitz::TinyVector&lt; int, tp_rank &gt;, 1 &gt; <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::<a class="el" href="classbwave_1_1WaveletDecomp.html#af170075b1e6a180a31bb3e4316f8207d">indices</a> </td>
          <td>(</td>
          <td class="paramtype">blitz::Array&lt; tp_Type, tp_rank &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the indices of the coefficients that this decomposition will/has produce(d) for the given data. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>original data or transformed data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An array of coefficient scaling indices which occur in the decomposed data.</dd></dl>
<p>There method is useful if you want to iterate over all wavelet/scaling coefficients in the decomposed data. Since wavelet decomposition is done in-place, it does not matter whether this method is called before or after decomposition of the data, since the data extents (which determine the possible indices will stay the same.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>coeffs(blitz::Array&lt;tp_Type,tp_rank&gt; &amp;data, blitz::TinyVector&lt;int, tp_rank&gt; indices) </dd></dl>

<p>Referenced by <a class="el" href="classbwave_1_1WaveletDecomp.html#a2650a3646c51ed0b3ae2f4601de6481a">bwave::WaveletDecomp&lt; tp_rank &gt;::normFactor()</a>.</p>

</div>
</div>
<a class="anchor" id="a2650a3646c51ed0b3ae2f4601de6481a"></a><!-- doxytag: member="bwave::WaveletDecomp::normFactor" ref="a2650a3646c51ed0b3ae2f4601de6481a" args="(blitz::TinyVector&lt; int, tp_rank &gt; indices) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::<a class="el" href="classbwave_1_1WaveletDecomp.html#a2650a3646c51ed0b3ae2f4601de6481a">normFactor</a> </td>
          <td>(</td>
          <td class="paramtype">blitz::TinyVector&lt; int, tp_rank &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the normalization factor for the specified coefficient type. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The index vector specifying the coefficient type </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The factor needed to normalize the coefficients.</dd></dl>
<p>The <a class="el" href="classbwave_1_1Wavelet.html" title="General Wavelet class.">Wavelet</a> and scaling coefficients are not automatically normalized after decomposition, otherwise integer applications would not be possible. Also, normalisation is unneeded or even unwanted for some applications. </p>

<p>References <a class="el" href="classbwave_1_1WaveletDecomp.html#af170075b1e6a180a31bb3e4316f8207d">bwave::WaveletDecomp&lt; tp_rank &gt;::indices()</a>, and <a class="el" href="classbwave_1_1WaveletDecomp.html#a2517305dd2b926d7cd0fe4b104482db3">bwave::WaveletDecomp&lt; tp_rank &gt;::wavelet()</a>.</p>

<p>Referenced by <a class="el" href="classbwave_1_1Wavelet.html#a2a75aacf6645d191078a839d1be5a70f">bwave::Wavelet::forwardFkt()</a>, and <a class="el" href="classbwave_1_1Wavelet.html#ab602c1aa2aab908f3d75f9160bf9dddc">bwave::Wavelet::inverseFkt()</a>.</p>

</div>
</div>
<a class="anchor" id="a0d51787edf5dc539915cdc08736deff6"></a><!-- doxytag: member="bwave::WaveletDecomp::storageMode" ref="a0d51787edf5dc539915cdc08736deff6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CoeffStorage <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::<a class="el" href="classbwave_1_1WaveletDecomp.html#a0d51787edf5dc539915cdc08736deff6">storageMode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the mode in which the wavelet/scaling coefficients are stored. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>CoeffStorage </dd></dl>

<p>Referenced by <a class="el" href="classbwave_1_1WaveletDecomp.html#abcf0d45cb9254f2beeac698c22b2abb9">bwave::WaveletDecomp&lt; tp_rank &gt;::apply()</a>, and <a class="el" href="classbwave_1_1WaveletDecomp.html#accdacebb53ce2791c965cdde9eb428d2">bwave::WaveletDecomp&lt; tp_rank &gt;::applyInv()</a>.</p>

</div>
</div>
<a class="anchor" id="a141d7f32187ccf3505b11a93ca14754e"></a><!-- doxytag: member="bwave::WaveletDecomp::storageMode" ref="a141d7f32187ccf3505b11a93ca14754e" args="(CoeffStorage newCS)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int tp_rank&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CoeffStorage <a class="el" href="classbwave_1_1WaveletDecomp.html">bwave::WaveletDecomp</a>&lt; tp_rank &gt;::<a class="el" href="classbwave_1_1WaveletDecomp.html#a0d51787edf5dc539915cdc08736deff6">storageMode</a> </td>
          <td>(</td>
          <td class="paramtype">CoeffStorage&#160;</td>
          <td class="paramname"><em>newCS</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the mode in which the wavelet/scaling coefficients are stored. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">newCS</td><td>the new storage mode</td></tr>
  </table>
  </dd>
</dl>
<p>Note that lifting-based operations (i.e. <code>apply</code>(...) and <code>applyInv</code>(...) only work in <code>NESTED_COEFFS</code> mode. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>CoeffStorage </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/pclz-02/oschulz/Data/Science/Projects/Gerda/Software/blitzwave/src/<a class="el" href="WaveletDecomp_8h_source.html">WaveletDecomp.h</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 17 2013 19:16:25 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
